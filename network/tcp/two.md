
## TCP 粘包和拆包的原因

我们知道 TCP 是以字节流的方式传输数据，传输的最小单位为一个报文段（segment）。  
TCP 首部 中 有个选项 (Options)的字段，常见的选项为 MSS （Maximum Segment Size 最大消息长度），它是收发双方协商通信时 每一个报文段 所能承载的 最大有效数据的长度。  
数据链路层 每次传输的数据 有个最大限制 MTU （Maximum Transmission Unit），一般是 1500 字节，超过这个量要分成多个报文段，    
MSS 则是这个最大限制减去 TCP 的首部，光是 要传输的数据的大小，一般为1460字节。  
MSS = MTU - Header  

TCP 为提高性能，发送端 会将需要发送的数据 发送到发送缓存，等待 缓存满了之后，再将缓存中的数据 发送到接收方。  
同理，接收方也有接收缓存 这样的机制，来接收数据。  


上面这些是发生 TCP 粘包和拆包的前提，下面是具体的原因：    
1. 要发送的数据 大于 TCP 发送缓冲区 剩余空间大小，将会发生拆包。  
2. 待发送数据 大于MSS（最大报文长度），TCP 在传输前 将进行拆包。  
3. 应用程序 写入数据 小于 剩余缓存大小，网卡 将应用多次写入的数据 先缓存起来，然后一起 发送到网络上，这将会发生粘包。  
4. 接收数据端 的应用层 没有及时读取 接收缓存中 的数据，将发生粘包。  





## TCP 粘包和拆包的解决方案

1. 设置定长消息，服务端 每次读取 既定长度的内容 作为一条完整消息。
2. 设置消息边界，数据结尾 增加 特殊字符分割。  
3. 使用 带消息头的协议，消息头 存储 消息开始标识 及 消息长度信息，接收方 获取消息头的时候 解析出 消息长度，然后 向后读取 该长度的内容。  
