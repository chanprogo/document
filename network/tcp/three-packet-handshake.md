
## 三次握手过程

• 客户端     SYN=1           seq=x     
• 服务器     SYN=1  ACK=1    ack=x+1    seq=y   
• 客户端            ACK=1    seq=x+1    ack=y+1      





## TCP 建立连接 为什么 要三次握手 而不是两次？  

防止  已过期的  连接请求报文  突然 又传送到 服务器，因而 产生错误

在双方两次握手 即可建立连接的情况下，假设客户端 发送 A 报文段 请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。


三次握手 才能 让双方 均确认 自己和对方的  发送和接收能力 都正常  
第一次握手：客户端只是发送 处请求报文段，什么都无法确认，而服务器 可以确认自己的接收能力 和 对方的发送能力正常；  
第二次握手：客户端 可以确认 自己发送能力和接收能力正常，对方 发送能力和接收能力正常；  
第三次握手：服务器 可以确认 自己发送能力和接收能力正常，对方 发送能力和接收能力正常；  


告知对方自己的 初始序号值，并确认 收到对方的 初始序号值

TCP 实现了可靠的数据传输，原因之一 就是 TCP 报文段中 维护了 序号字段 和 确认序号字段，
通过这两个字段 双方都可以知道 在自己发出的数据中，哪些是 已经被对方确认接收的。
这两个字段的值 会在初始序号值 的基础递增，
如果是两次握手，只有发起方的初始序号 可以得到确认，而另一方的初始序号 则得不到确认。






## TCP 建立连接为什么要三次握手而不是四次？

因为三次握手 已经
1. 可以 确认双方的 发送 接收 能力正常，
2. 双方 都知道 彼此已经准备好，
3. 而且 也可以完成 对双方初始序号值 的确认，

也就无需再第四次握手了。









## 有一种网络攻击 是利用了 TCP 建立连接机制 的漏洞？

在三次握手过程中，服务器在收到了客户端的 SYN 报文段后，会分配并初始化 连接变量和缓存，并向客户端发送 SYN + ACK 报文段，
这相当于是打开了一个“半开连接 (half-open connection)”，会消耗服务器资源。  

如果客户端 正常返回了 ACK 报文段，那么双方可以正常建立连接，否则，服务器在等待一分钟后 会终止这个 “半开连接” 并回收资源。  

这样的机制为 SYN 洪泛攻击 (SYN flood attack)提供了机会，这是一种经典的 DoS攻击 (Denial of Service，拒绝服务攻击)，所谓的拒绝服务攻击 就是通过进行攻击，使受害主机或网络不能提供良好的服务，从而 间接达到攻击的目的。  
在 SYN 洪泛攻击中，攻击者发送大量的 SYN 报文段 到服务器请求建立连接，但是却不进行第三次握手，这会导致服务器打开大量的半开连接，消耗大量的资源，最终无法进行正常的服务。



解决方法：  

SYN Cookies，现在大多数 主流操作系统 都有这种防御系统。SYN Cookies 是对 TCP 服务器端的 三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。  

它的原理是，在服务器接收到 SYN 报文段并返回 SYN + ACK 报文段时，不再打开一个半开连接，也不分配资源，  
而是根据这个 SYN 报文段的重要信息 (包括 源和目的 IP 地址，端口号 和一个秘密数)，利用特定散列函数 计算出一个 cookie 值。这个 cookie 作为 将要返回的 SYN + ACK 报文段的 初始序列号(ISN)。  
当客户端返回一个 ACK 报文段时，服务器 根据首部字段信息 计算 cookie，与返回的确认序号(初始序列号 + 1)进行对比，

如果相同，则是一个正常连接，然后分配资源并建立连接，
否则拒绝建立连接。  
