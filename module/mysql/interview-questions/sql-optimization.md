

## 避免 SELECT *   

从数据库里 读出越多的数据，那么查询就会 变得越慢。
并且，如果你的数据库服务器 和 WEB 服务器 是两台独立的服务器的话，这还会增加 网络传输的负载。     



## 拆分大的 DELETE 或 INSERT 语句  



## 当只要一行数据时使用 LIMIT 1  

当你查询表 的有些时候，你已经 知道 结果只会有一条结果，
但因为你可能需要去 fetch 游标，或是 你也许会 去检查 返回的记录数。 
在这种情况下，加上 `LIMIT 1` 可以增加性能。MySQL 数据库引擎 会在找到一条数据后 停止搜索，而不是继续往后 查找下一条 符合记录的数据。   


## 为查询缓存 优化你的查询  

大多数的 MySQL 服务器都开启了查询缓存。这是提高性能最有效的方法之一，而且这是被 MySQL 的数据库引擎处理的。
当有很多相同的查询 被执行了多次的时候，这些查询结果 会被放到一个缓存中，这样，后续的相同的查询 就不用操作表 而直接访问缓存结果了。 
这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为我们某些查询语句 会让 MySQL 不使用缓存。

请看下面的示例：

```
// 查询缓存不开启 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()"); 

// 开启查询缓存 
$today = date("Y-m-d"); 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'");
```

上面两条 SQL 语句的差别就是 CURDATE() ，MySQL 的查询缓存对这个函数不起作用。
所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会 开启查询缓存，因为这些函数的返回 是会不定的易变的。
所以，你所需要的就是 用一个变量来代替 MySQL 的函数，从而开启缓存。  











## Prepared Statements  

Prepared Statements 很像存储过程，是一种运行在后台的 SQL 语句集合，
我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。 

可以检查 一些 你绑定好的变量，这样可以保护你的程序 不会受到 “SQL注入式” 攻击。

在性能方面，当一个相同的查询 被使用多次 的时候，这会为你 带来可观的 性能优势。你可以给这些 Prepared Statements 定义一些参数，而 MySQL 只会解析一次。 








## MySQL 的删除操作和更新（逻辑删）操作哪个好  

首先 先 简述两个操作的流程  

删除：  
当删除的数据 不影响 所在的节点，则不用 调整（不是该节点中的 最大或者最小值）。  
当删除的数据 是所在节点的 最大或者最小值，则需要 调整父节点的索引值。  
当删除的数据 后 导致当前节点个数不足，如果兄弟节点 有多余节点时 则借用，否则 合并兄弟节点。若合并 操作影响 双亲节点后 会递归相同操作 合并双亲节点。  
根据辅助索引 找到这行数据
逻辑删 数据页 的数据
删除 索引上的 子节点

更新（假设有一个字段表 标记 这行数据的 是否删除）：  
根据 辅助索引 找到 这行数据  
回表 更新 这行数据（此处 不赘述 从连接器到内存 的内容）  


为什么不建议删除数据，而是建议软删除（逻辑删）  
基于存储结构：  基于 b+ 树的  索引 调整 结构 耗时，并且 删除后 表空间 并没有减少  
基于业务：  业务数据丢失，出现问题时 难以追溯  

综上所述，是更新（逻辑删）  效率更高，以及方便追溯  




