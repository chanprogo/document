

## 避免 SELECT *   

从数据库里 读出越多的数据，那么查询就会 变得越慢。
并且，如果你的数据库服务器 和 WEB 服务器 是两台独立的服务器的话，这还会增加 网络传输的负载。     



## 拆分大的 DELETE 或 INSERT 语句  



## 当只要一行数据时使用 LIMIT 1  

当你查询表 的有些时候，你已经 知道 结果只会有一条结果，
但因为你可能需要去 fetch 游标，或是 你也许会 去检查 返回的记录数。 
在这种情况下，加上 `LIMIT 1` 可以增加性能。MySQL 数据库引擎 会在找到一条数据后 停止搜索，而不是继续往后 查找下一条 符合记录的数据。   


## 为查询缓存 优化你的查询  

大多数的 MySQL 服务器都开启了查询缓存。这是提高性能最有效的方法之一，而且这是被 MySQL 的数据库引擎处理的。
当有很多相同的查询 被执行了多次的时候，这些查询结果 会被放到一个缓存中，这样，后续的相同的查询 就不用操作表 而直接访问缓存结果了。 
这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为我们某些查询语句 会让 MySQL 不使用缓存。

请看下面的示例：

```
// 查询缓存不开启 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()"); 

// 开启查询缓存 
$today = date("Y-m-d"); 
$r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'");
```

上面两条 SQL 语句的差别就是 CURDATE() ，MySQL 的查询缓存对这个函数不起作用。
所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会 开启查询缓存，因为这些函数的返回 是会不定的易变的。
所以，你所需要的就是 用一个变量来代替 MySQL 的函数，从而开启缓存。  











## Prepared Statements  

Prepared Statements 很像存储过程，是一种运行在后台的 SQL 语句集合，
我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。 

可以检查 一些 你绑定好的变量，这样可以保护你的程序 不会受到 “SQL注入式” 攻击。

在性能方面，当一个相同的查询 被使用多次 的时候，这会为你 带来可观的 性能优势。你可以给这些 Prepared Statements 定义一些参数，而 MySQL 只会解析一次。 









