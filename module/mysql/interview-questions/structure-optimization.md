
## 为每张表设置一个 ID  

我们应该为数据库里的每张表  都设置一个 ID 做为其主键，而且最好的是一个 INT 型的（推荐使用UNSIGNED），
并设置上自动增加的 AUTO_INCREMENT 标志。 

就算是你 users 表有一个主键叫 “email” 的字段，你也别让它成为主键。
使用 VARCHAR 类型 来当主键 会使得 性能下降。
另外，在你的程序中，你应该使用表的 ID 来构造你的数据结构。 


而且，在 MySQL 数据引擎下，还有一些操作 需要使用主键，在这些情况下，主键的性能和设置  变得非常重要，比如，集群，分区…… 

在这里，只有一个情况是例外，那就是 “关联表” 的 “外键”，
也就是说，这个表的主键，通过若干个 别的表 的主键构成。我们把这个情况叫做 “外键”。

比如：有一个 “学生表” 有学生的 ID，有一个 “课程表” 有课程ID，
那么，“成绩表” 就是 “关联表” 了，其关联了学生表和课程表，在成绩表中，学生 ID 和课程 ID 叫“外键”，其共同组成 主键。






## 使用 ENUM 而不是 VARCHAR  

ENUM 类型是 非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。

这样一来，用这个字段来做一些选项列表变得相当的完美。 

如果你有一个字段，比如 “性别”，“国家”，“民族”，“状态” 或 “部门”，你知道这些字段的取值 是有限而且固定的，
那么，你应该使用 ENUM 而不是 VARCHAR。 






## 分库 分表

首先 分库 分表 分为 垂直 和 水平 两个方式，一般来说 我们拆分的顺序 是  先垂直  后水平。

垂直分库： 基于 现在 微服务 拆分来说，都是已经做到了   垂直分库了。  
垂直分表： 如果 表字段 比较多，将  不常用的、数据较大的   等等做拆分。  

水平分表  
首先根据 业务场景 来决定 使用什么字段 作为 分表字段（sharding_key），  
比如我们现在日订单 1000 万，我们大部分的场景 来源于 C 端，我们可以用 user_id 作为 sharding_key，
数据查询 支持到 最近 3 个月 的订单，超过 3 个月的 做归档处理，那么 3 个月 的数据量就是 9 亿，可以分 1024 张表，那么每张表的数据 大概就在 100 万左右。

比如用户 id 为 100，那我们都经过 hash(100)，然后对 1024 取模，就可以 落到 对应的表 上了。




## 那分表后的 ID 怎么 保证 唯一性 的呢？

因为我们主键 默认 都是 自增的，那么 分表之后的 主键 在不同表 就肯定会有冲突了。有几个办法考虑：   

1. 设定步长，比如 1-1024 张表 我们分别设定 1-1024 的 基础步长，这样主键 落到不同的表 就不会冲突了。  
2. 分布式ID，自己实现 一套分布式ID生成算法 或者 使用开源的 比如雪花算法 这种。  
3. 分表后 不使用主键 作为查询依据，而是 每张表 单独 新增一个字段 作为 唯一主键 使用，比如  订单表订单号  是唯一的，不管最终落在哪张表  都基于订单号   作为查询依据，更新也一样。   





## 分表后非 sharding_key 的查询 怎么处理呢？

可以做一个 mapping 表，比如这时候 商家要 查询订单 列表 怎么办呢？  
不带 user_id 查询的话 你总不能 扫全表吧？所以我们可以做 一个映射关系表，保存商家和用户的关系，查询的时候 先通过商家查询到用户列表，再通过 user_id 去查询。    

打宽表，一般而言，商户端 对数据实时性 要求并不是很高，比如 查询订单列表，可以把 订单表 同步到 离线（实时）数仓，
再基于数仓 去做成 一张宽表，再基于 其他如 es 提供查询服务。  

数据量不是很大的话，比如后台的 一些查询之类的，也可以通过 多线程 扫表，然后 再聚合结果的方式 来做。
或者异步的形式也是可以的。  

