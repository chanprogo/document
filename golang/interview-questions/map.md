
## 为什么 map 不支持并发而 sync.map 支持并发  

map 不支持并发 是因为  
当 赋值 和 删除 时 是置写操作位。  
当置了之后 有别的协程 用任何操作 进行 来时 都会报错。   

如果想要 map 线程安全，解决方案 一般是用 
sync.map、      
互斥锁/读写锁 + map  



sync.map 使用了 读写分离 来去 保证线程安全的，  
sync.map 的数据结构 分为    读 map、写 map、还有  互斥锁  以及 一个 记录穿透次数的值。  

具体实现是  每个协程  来读取时  都会先读取  读部分的 kv，  
没有 则去读  写部分的 kv（操作写部分时 都会上锁）。  

当 穿透到 写部分的次数 大于 写部分的长度 时 
就会将 写部分 同步到 读部分 并且把 写部分清空。  

所以多协程下 一般都会 先打到 无锁的 读部分，这能保证 读取性能    